import Client from './Client';
import SocketWrapper from './SocketWrapper';
import { mock } from 'jest-mock-extended';
import { types as soup } from 'mediasoup';
import Room from './Room';

import Gathering from './Gathering';
jest.mock('./Gathering');


describe('When Client class is created it', () => {
  let socketWrapper : SocketWrapper;
  let client: Client;
  beforeEach(() => {
    socketWrapper = mock<SocketWrapper>();
    client = new Client({ws: socketWrapper});
  });
  it('can be successfully instantiated', () => {
    expect(client).toBeTruthy();
  });
  
  it('has a uuid autogenerated if not provided', () => {
    expect(client).toHaveProperty('id');
    // console.log('uuid:', client.id);
    expect(client.id).toBeDefined();
  });

  it('its possible to assign custom uuid', ()=> {
    const randomString = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    client = new Client({ws: socketWrapper, id: randomString});
    expect(client).toHaveProperty('id');
    expect(client.id).toBe(randomString);
  });


});

describe('client instance with exposed private messageHandler', () => {
  let socketWrapper : SocketWrapper;
  let client: Client;
  let messageHandler: (msg: SocketMessage<UnknownMessageType>) => void;
  beforeEach(() => {
    socketWrapper = mock<SocketWrapper>();
    client = new Client({ws: socketWrapper});
    // @ts-expect-error I allow private access in tests because I'm the chief!!!
    messageHandler = client.handleReceivedMsg;

  });

  it('can set RtpCapabilities from valid incoming message', () => {
    // const message = mock<SocketMessage<SetRtpCapabilities>>();
    const validMsgObj: SocketMessage<UnknownMessageType> = {
      type: 'setRtpCapabilities',
      data: {codecs: []},
    };

    messageHandler(validMsgObj);
    // console.log(client.rtpCapabilities);
    expect(client.rtpCapabilities).toEqual<soup.RtpCapabilities>(validMsgObj.data);
  });

  it('can NOT join a gathering if doesnt exist', () => {
    const spy = jest.spyOn(console, 'warn').mockImplementation();
    const gatheringId = 'lkj23lkjh234';
    Gathering.gatherings.set(gatheringId, new Gathering(gatheringId));
    // const gatheringName = 'cool-gathering';
    const nonExtistingGatheringId = '4j4j4j4j4';
    const validJoinGatheringRequest: SocketMessage<JoinGathering> = {
      ackNeeded: true,
      type: 'joinGathering',
      data: {id: nonExtistingGatheringId}
    };
    messageHandler(validJoinGatheringRequest);

    expect(client.gathering).toBeUndefined();
    expect(spy).toBeCalled();
    spy.mockRestore();
  });
  
  it('can join a gathering from valid join request', () => {
    const gatheringId = 'lkj23lkjh234';
    const gathering =  new Gathering(gatheringId);
    Gathering.gatherings.set(gatheringId, gathering);
    const validJoinGatheringRequest: SocketMessage<JoinGathering> = {
      ackNeeded: true,
      type: 'joinGathering',
      data: {id: gatheringId}
    };
    messageHandler(validJoinGatheringRequest);

    expect(client.gathering).toBeDefined();
    expect(client.gathering).toBe(gathering);
    // expect(client.gathering?.id).toBe(gatheringId);
  });

  // it('can NOT join a gathering from valid join request if isnt authorized', () => {
  //   // const gatheringName = 'cool-gathering';
  //   const validGatheringId = '4j4j4j4j4';
  //   const validJoinRoomRequest: SocketMessage<JoinGathering> = {
  //     ackNeeded: true,
  //     type: 'joinGathering',
  //     data: {id: validGatheringId}
  //   };
  //   messageHandler(validJoinRoomRequest);

  //   expect(client.gathering).toBeDefined();
  // });

  it('returns RouterCapabilities to client when requested', () => {
    const room = mock<Room>();
    const caps = mock<soup.RtpCapabilities>();
    room.getRtpCapabilities.mockReturnValue(caps);
    client.room = room;
    const requestMsg: SocketMessage<RequestMessageType> = {
      request: true,
      type:'getRouterRtpCapabilities' 
    };
    messageHandler(requestMsg);

    expect(socketWrapper.send).toBeCalledTimes(1);
  });

  it('can not return RouterCapabilities to client if isnt in a room', () => {
    const spy = jest.spyOn(console, 'warn').mockImplementation();
    const requestMsg: SocketMessage<RequestMessageType> = {
      request: true,
      type:'getRouterRtpCapabilities' 
    };
    messageHandler(requestMsg);

    expect(socketWrapper.send).toBeCalledTimes(0);
    expect(spy).toBeCalledTimes(1);
    spy.mockRestore();
  });

  it('can join a room from valid join request', () => {
    const gatheringId = '3lkjh3kjhlkjg4lkj';
    const gathering = new Gathering(gatheringId);
    const roomId = 'h3öjkh5öjh235';
    const room = mock<Room>();
    gathering.rooms.set(roomId, room);

    Gathering.gatherings.set(gatheringId, gathering);

    client.gathering = gathering;

    const validJoinRoomRequest: SocketMessage<JoinRoom> = {
      ackNeeded: true,
      type: 'joinRoom',
      data: {id: roomId,}
    };
    messageHandler(validJoinRoomRequest);

    expect(client.room).toBeDefined();
  });
});